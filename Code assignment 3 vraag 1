import os
import numpy as np
import matplotlib.pyplot as plt

from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Flatten
from tensorflow.keras.layers import Conv2D, MaxPool2D
from tensorflow.keras.optimizers import SGD
from tensorflow.keras.callbacks import ModelCheckpoint, TensorBoard
from sklearn.metrics import roc_curve, auc

# the size of the images in the PCAM dataset
IMAGE_SIZE = 96

def get_pcam_generators(base_dir, train_batch_size=32, val_batch_size=32):
     # dataset parameters
     TRAIN_PATH = os.path.join(base_dir, 'train+val', 'train')
     VALID_PATH = os.path.join(base_dir, 'train+val', 'valid')
     RESCALING_FACTOR = 1./255
     
     # instantiate data generators
     datagen = ImageDataGenerator(rescale=RESCALING_FACTOR)

     train_gen = datagen.flow_from_directory(TRAIN_PATH,
                                             target_size=(IMAGE_SIZE, IMAGE_SIZE),
                                             batch_size=train_batch_size,
                                             class_mode='binary')

     val_gen = datagen.flow_from_directory(VALID_PATH,
                                             target_size=(IMAGE_SIZE, IMAGE_SIZE),
                                             batch_size=val_batch_size,
                                             class_mode='binary',
                                             shuffle=False)
     
     return train_gen, val_gen

def get_model(kernel_size=(3,3), pool_size=(4,4), first_filters=32, second_filters=64):
     # build the model
     model = Sequential()

     model.add(Conv2D(first_filters, kernel_size, activation = 'relu', padding = 'same', input_shape = (IMAGE_SIZE, IMAGE_SIZE, 3)))
     model.add(MaxPool2D(pool_size = pool_size)) 

     model.add(Conv2D(second_filters, kernel_size, activation = 'relu', padding = 'same'))
     model.add(MaxPool2D(pool_size = pool_size))

     model.add(Flatten())
     model.add(Dense(64, activation = 'relu'))
     model.add(Dense(1, activation = 'sigmoid'))
    
     # compile the model
     model.compile(SGD(learning_rate=0.01, momentum=0.95), loss = 'binary_crossentropy', metrics=['accuracy'])

     return model
    
def train_model(model, train_gen, val_gen, weights_filepath, model_name, epochs=3):
    # define the model checkpoint and Tensorboard callbacks
    checkpoint = ModelCheckpoint(weights_filepath, monitor='val_loss', verbose=1, save_best_only=True, mode='min')
    tensorboard = TensorBoard(log_dir=os.path.join('logs', model_name))
    callbacks_list = [checkpoint, tensorboard]

    # train the model if necessary
    if not os.path.exists(weights_filepath):
        train_steps = train_gen.n//train_gen.batch_size
        val_steps = val_gen.n//val_gen.batch_size

        history = model.fit(train_gen, steps_per_epoch=train_steps, 
                            validation_data=val_gen,
                            validation_steps=val_steps,
                            epochs=epochs,
                            callbacks=callbacks_list)
    else:
        print("Weights already exist. Skipping training.")


def calculate_roc_and_auc(model, val_gen):
    # Predict probabilities for the validation set
    predictions = model.predict(val_gen)
    
    # Calculate the false positive rate (FPR) and true positive rate (TPR)
    fpr, tpr, thresholds = roc_curve(val_gen.classes, predictions)
    
    # Calculate the area under the ROC curve (AUC)
    roc_auc = auc(fpr, tpr)
    
    return fpr, tpr, roc_auc

def plot_roc_curve(fpr, tpr, roc_auc):
    # Plotting the ROC curve
    plt.figure(figsize=(8, 6))
    plt.plot(fpr, tpr, color = 'gray', lw = 2, label = "ROC curve (area = %0.2f)"  % roc_auc)
    plt.plot([0, 1], [0,1], color = 'gray', linestyle = '--')
    plt.xlabel("False Positive Rate")
    plt.ylabel("True Positive Rate")
    plt.title("Receiver Operating Characteristic (ROC) Curve")
    plt.legend(loc = "lower right")
    plt.show()

def calculate_and_plot_ROC_AUC():
    # get the model
    model = get_model()
    
    for layer in model.layers:
        print(layer.output_shape)
        
    # get the data generators
    train_gen, val_gen = get_pcam_generators(r"C:\Users\20203894\Documents\8p361")
    
    # train the model if necessary
    train_model(model, train_gen, val_gen, "my_first_cnn_model_weights.hdf5", model_name="my_first_cnn_model", epochs=3)

    # Load the trained model weights
    model.load_weights("my_first_cnn_model_weights.hdf5")
    
    # calculate ROC and AUC
    fpr, tpr, roc_auc = calculate_roc_and_auc(model, val_gen)
    
    # plot ROC curve
    plot_roc_curve(fpr, tpr, roc_auc)
    
    print("AUC", roc_auc)

calculate_and_plot_ROC_AUC()   
