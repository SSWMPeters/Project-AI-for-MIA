import os
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Dense, GlobalAveragePooling2D, Dropout
from tensorflow.keras.optimizers import SGD
from tensorflow.keras.callbacks import ModelCheckpoint, TensorBoard
from tensorflow.keras.applications.mobilenet_v2 import MobileNetV2, preprocess_input

def get_pcam_generators(base_dir, train_batch_size=32, val_batch_size=32):
    train_path = os.path.join(base_dir, 'train+val', 'train')
    valid_path = os.path.join(base_dir, 'train+val', 'valid')

    datagen = ImageDataGenerator(preprocessing_function=preprocess_input)

    train_gen = datagen.flow_from_directory(train_path,
                                            target_size=(IMAGE_SIZE, IMAGE_SIZE),
                                            batch_size=train_batch_size,
                                            class_mode='binary')

    val_gen = datagen.flow_from_directory(valid_path,
                                          target_size=(IMAGE_SIZE, IMAGE_SIZE),
                                          batch_size=val_batch_size,
                                          class_mode='binary')

    return train_gen, val_gen

IMAGE_SIZE = 96
input_shape = (IMAGE_SIZE, IMAGE_SIZE, 3)

input = Input(input_shape)
pretrained = MobileNetV2(input_shape=input_shape, include_top=False, weights=None)
output = pretrained(input)
output = GlobalAveragePooling2D()(output)
output = Dropout(0.5)(output)
output = Dense(1, activation='sigmoid')(output)
model = Model(input, output)

model.compile(SGD(learning_rate=0.001, momentum=0.95), loss='binary_crossentropy', metrics=['accuracy'])

train_gen, val_gen = get_pcam_generators(r'C:\Users\20203894\Documents\8p361')

model_name = 'my_first_transfer_model_adapted'
model_filepath = model_name + '.json'
weights_filepath = model_name + '_weights.hdf5'

model_json = model.to_json()
with open(model_filepath, 'w') as json_file:
    json_file.write(model_json)

checkpoint = ModelCheckpoint(weights_filepath, monitor='val_loss', verbose=1, save_best_only=True, mode='min')
tensorboard = TensorBoard(os.path.join('logs', model_name))
callbacks_list = [checkpoint, tensorboard]

train_steps = train_gen.n // train_gen.batch_size // 20
val_steps = val_gen.n // val_gen.batch_size // 20

history = model.fit(train_gen, steps_per_epoch=train_steps,
                    validation_data=val_gen,
                    validation_steps=val_steps,
                    epochs=10,
                    callbacks=callbacks_list)

def calculate_roc_and_auc(model, val_gen):
    predictions = model.predict(val_gen)
    fpr, tpr, thresholds = roc_curve(val_gen.classes, predictions)
    roc_auc = auc(fpr, tpr)
    return fpr, tpr, roc_auc

def plot_roc_curve(fpr, tpr, roc_auc):
    plt.figure(figsize=(8, 6))
    plt.plot(fpr, tpr, color='gray', lw=2, label="ROC curve (area = %0.2f)" % roc_auc)
    plt.plot([0, 1], [0, 1], color='gray', linestyle='--')
    plt.xlabel("False Positive Rate")
    plt.ylabel("True Positive Rate")
    plt.title("Receiver Operating Characteristic (ROC) Curve")
    plt.legend(loc="lower right")
    plt.show()

def calculate_and_plot_ROC_AUC():
    fpr, tpr, roc_auc = calculate_roc_and_auc(model, val_gen)
    plot_roc_curve(fpr, tpr, roc_auc)
    print("AUC", roc_auc)

calculate_and_plot_ROC_AUC()

